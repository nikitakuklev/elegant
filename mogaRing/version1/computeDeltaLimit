#!/bin/sh  
# \
exec oagtclsh "$0" "$@"

set auto_path [linsert $auto_path 0  $env(OAG_TOP_DIR)/oag/apps/lib/$env(HOST_ARCH)]
set auto_path [linsert $auto_path 0 $env(OAG_TOP_DIR)/oag/lib_patch/$env(HOST_ARCH)]
APSStandardSetup

set usage {usage: computeDeltaLimit -input <filename> -deltaLimit <value>}
set input ""
set deltaLimit 2.35e-2
set args $argv
if {[APSStrictParseArguments {input deltaLimit}] || ![string length $input]} {
    return -code error "$usage"
}

# Reorganize to give position vs turn for each particle
if [catch {exec sddsprocess -nowarning $input -pipe=out -define=column,Turn,Pass,type=long \
             | sddscombine -pipe -merge \
             | sddssort -pipe -col=particleID -col=Turn \
             | sddsbreak -pipe -change=particleID \
             | sddsprocess -nowarning -pipe=in $input.1 -process=p,first,pFirst "-define=parameter,delta,pFirst pCentral - pCentral /" \
             -process=Turn,max,TurnMax} result] {
    return -code error "Error: $result"
}


# Look for cases where the particle is lost and find the minimum |delta|
if [catch {exec sddscollapse $input.1 -pipe=out \
             | sddsprocess -nowarning -pipe \
             -process=TurnMax,max,TurnMaxMax \
             "-define=col,Lost,TurnMaxMax TurnMax -,type=short" \
             "-define=col,deltaAbs,delta abs" \
             -filter=col,Lost,0,0,! \
             -process=deltaAbs,min,%sMin \
             | sdds2stream -pipe -parameter=deltaAbsMin} result] {
    return -code error "Error: $result"
}

if {![string match *e+308 $result] && [expr $result<$deltaLimit]} {
    set deltaLimit $result
}


# Look for undefined tunes
if [catch {exec sddsnaff $input.1 -pipe=out -nowarning \
             -column=Turn -pair=x,xp -pair=y,yp -terminate=frequencies=1 \
             | sddsexpand -pipe \
             | sddscollapse -pipe \
             | sddsprocess -nowarning -pipe "-define=column,deltaAbs,delta abs" \
             -filter=col,deltaAbs,1e-3,1 \
             | sddssort -pipe -column=deltaAbs \
             | sddsprocess -nowarning -pipe=in $input.naff -process=*Frequency,first,%s0 } result] {
    return -code error "Error: delta limit 2: $result"
}

if [catch {exec sddsprocess -nowarning $input.naff -pipe=out -filter=col,xFrequency,-1,-1,yFrequency,-1,-1,|  \
             -process=deltaAbs,min,%sMin \
             | sdds2stream -pipe -parameter=deltaAbsMin} result] {
    return -code error "Error: delta limit 3: $result"
}
if {![string match *e+308 $result] && [expr $result<$deltaLimit]} {
    set deltaLimit $result
}

# Look for integer or half-integer crossings
foreach plane {x y} {
    if [catch {exec sddsprocess $input.naff -pipe=out -nowarning \
                 "-define=column,badTune,${plane}Frequency 2 * int ${plane}Frequency0 2 * int - abs" \
                 -filter=col,badTune,1,1 \
                 -process=deltaAbs,min,%sMin \
                 | sdds2stream -pipe -parameter=deltaAbsMin} result] {
        return -code error "Error: delta limit 4 ($plane): $result"
    }
    if {![string match *e+308 $result] && [expr $result<$deltaLimit]} {
        set deltaLimit $result
    }
}

puts stdout "$deltaLimit"





    

