#!/bin/sh  
# \
exec oagwish "$0" "$@"

if {![info exists env(OAG_TOP_DIR)]} { set env(OAG_TOP_DIR) /usr/local }
set auto_path [linsert $auto_path 0  $env(OAG_TOP_DIR)/oag/apps/lib/$env(HOST_ARCH)]

set usage "usage: longitCalcs -twiss <filename> \[-voltage <MV>\]"
set twiss ""
set voltage -1.0
set args $argv
if {[APSStrictParseArguments {twiss voltage}] || ![string length $twiss]} {
    puts stderr $usage
    exit 1
}
if ![file exists $twiss] {
    puts stderr "Not found: $twiss"
    exit 1
}

set dataItemList [list U0 Sdelta0 ex0 alphac pCentral revFreq sMax]
if [catch {exec sddsconvert $twiss -pipe=out -topage=1 \
             | sddsprocess -pipe -process=s,max,sMax \
             "-define=parameter,revFreq,sMax pCentral beta.p c_mks * / rec" \
             | sdds2stream -pipe \
             -parameter=[join $dataItemList ,]} dataList] {
    puts stderr "$dataList"
    exit 1
}
set index 0
foreach item $dataItemList {
    set ${item} [lindex $dataList $index]
    incr index
}
set revFreq1 [expr $revFreq]
set sMax1 [expr $sMax]

APSApplication . -name longitCalcs 
set harmonic 1296
set extradE 0
set harmonic2 3
set voltage2 0
set superPeriods 1
if [expr $voltage<0] {
    # initial start with overvoltage of 1.5
    # to avoid problem with arcsin function
    set voltage [expr $superPeriods*($U0+$extradE) * 1.5]
}

APSLabeledEntry .voltage -parent .userFrame \
  -label "Voltage (MV): " -textVariable voltage -width 22
APSLabeledEntry .harmonic -parent .userFrame \
  -label "Harmonic number: " -textVariable harmonic -width 22 -type integer
APSLabeledEntry .sdelta -parent .userFrame \
    -label "Sigma P/P0: " -textVariable Sdelta0 -width 22
APSLabeledEntry .extradE -parent .userFrame \
    -label "Additional dE (MeV/period/turn): " -textVariable extradE -width 22
APSLabeledEntry .super -parent .userFrame \
    -label "Superperiods: " -textVariable superPeriods -width 22 
foreach item {voltage harmonic sdelta extradE super} {
    bind .userFrame.$item.entry <Return> compute
}

APSFrame .hharm -parent .userFrame  -label "Harmonic cavity" -width 22
set harmonicMode None
APSRadioButtonFrame  .mode -parent .userFrame.hharm.frame -label "Mode: " \
    -orientation horizontal -variable harmonicMode \
    -buttonList [list None "Opt.Lengthen" "Custom"] \
    -valueList [list None OptLengthen Custom] \
    -commandList [list compute compute compute]
set harmonicRatio 4
set voltageRatio 0
set harmonicPhase 0
APSLabeledEntry .harmonicRatio -parent .userFrame.hharm.frame \
    -label "Freq. ratio" -textVariable harmonicRatio -type integer -width 22
APSLabeledEntry .voltageRatio -parent .userFrame.hharm.frame \
    -label "Volt. ratio" -textVariable voltageRatio -width 22 -type real
APSLabeledEntry .harmonicPhaseDeg -parent .userFrame.hharm.frame \
    -label "Phase (deg)" -textVariable harmonicPhaseDeg -width 22 -type real
bind .userFrame.hharm.frame.harmonicRatio.entry <Return> compute
bind .userFrame.hharm.frame.voltageRatio.entry <Return> compute
bind .userFrame.hharm.frame.harmonicPhaseDeg.entry <Return> compute
set lastHarmonicMode None

set synchTune 0
set bunchLength 0
set bunchDuration 0
set synchPhase 0
set synchPhaseDeg 0
set overVoltage 0
set rfAcceptance 0
set rfFrequency 0
set synchFreq 0
set coupling 0
APSLabeledOutput .length -parent .userFrame \
    -label "Circumference (m): " -textVariable sMax1 -width 22
APSLabeledOutput .revFreq -parent .userFrame \
    -label "Rev. frequency (MHz): " -textVariable revFreq1 -width 22
APSLabeledOutput .rfFreq -parent .userFrame \
    -label "RF frequency (MHz): " -textVariable rfFrequency -width 22
APSLabeledOutput .synchphase -parent .userFrame \
  -label "Synchronous Phase: " -textVariable synchPhaseDeg -width 22
APSLabeledOutput .overvolt -parent .userFrame \
    -label "Over Voltage: " -textVariable overVoltage  -width 22
APSLabeledOutput .accept -parent .userFrame \
    -label "RF Acceptance: " -textVariable rfAcceptance -width 22
APSLabeledOutput .nus -parent .userFrame \
  -label "Synchrotron Tune: " -textVariable synchTune  -width 22
APSLabeledOutput .nuf -parent .userFrame \
  -label "Synchrotron Frequency (Hz): " -textVariable synchFreq  -width 22
APSLabeledOutput .blen -parent .userFrame \
  -label "Bunch length (m): " -textVariable bunchLength -width 22
APSLabeledOutput .bdur -parent .userFrame \
  -label "Bunch duration (s): " -textVariable bunchDuration -width 22
APSLabeledOutput .coupling -parent .userFrame \
  -label "Longitudinal coupling: " -textVariable coupling -width 22

set fractionalSpan 0.25
APSLabeledEntry .span -parent .userFrame \
  -label "Calculation half-span: " -textVariable fractionalSpan -width 22 \
    -contextHelp "Half-span of the bunch distribution calculation in units of the rf period. Changing this may resolve numerical problems for long bunches."

proc compute {args} {
    set plot 0
    APSStrictParseArguments {plot}
    global dataItemList
    eval global $dataItemList bunchLength harmonic voltage synchPhaseDeg
    global overVoltage rfAcceptance rfFrequency synchFreq coupling extradE synchTune
    global bunchDuration superPeriods revFreq1 sMax1 sMax
    global harmonicRatio voltageRatio harmonicMode lastHarmonicMode harmonicPhaseDeg
    global pi cMKS U1 sMax1 revFreq1 energy omegaRF rfFrequency

    if [expr $harmonicRatio<=1] {
        set harmonicMode None
        set harmonicRatio 1
    }

    set pi 3.141592653589793
    set cMKS 2.997924580000000e+08
    set U1 [expr $superPeriods*($U0+$extradE)]
    set sMax1 [expr $superPeriods*$sMax]
    set revFreq1 [expr $revFreq/$superPeriods]
    set energy [expr sqrt($pCentral*$pCentral+1)*0.51099906]
    set omegaRF [expr $harmonic*2*$pi*$revFreq1]
    set rfFrequency [expr $omegaRF/(2*$pi*1.0e6)]

    set overVoltage [expr $voltage/$U1]
    switch $harmonicMode {
        None {
            set voltageRatio 0
            set harmonicPhaseDeg 0
            set synchPhase [expr asin($U1/$voltage)]
            set rfAcceptance [expr sqrt(2*$U1/($pi*$alphac*$harmonic*$energy)*(sqrt($overVoltage*$overVoltage-1)-acos(1/$overVoltage)))]
            set synchTune [expr sqrt($alphac*$harmonic*cos($synchPhase)*$voltage/(2*$pi*$energy))]
            set synchFreq [expr $synchTune*$revFreq1]
            set bunchLength [expr $Sdelta0*$cMKS*sqrt($alphac*$energy/($revFreq1*$omegaRF*cos($synchPhase)*$voltage))]
            set coupling [expr sqrt($alphac*$voltage*cos($synchPhase)*$omegaRF/($energy*$revFreq1*4.0))]
            set bunchDuration [expr $bunchLength/$cMKS]
        }
        OptLengthen {
            set m $harmonicRatio*1.0
            set f1 [expr $m*$m/($m*$m-1)/$overVoltage]
            set synchPhase [expr asin($f1)]
            set k [expr sqrt(1/($m*$m) - 1/(($m*$m-1)*pow($overVoltage,2)))]
            set voltageRatio $k
            set harmonicPhase [expr asin(-1/($overVoltage*($m*$m-1)*$k))]
            set harmonicPhaseDeg [expr $harmonicPhase*180/$pi]
            if [expr $harmonicPhaseDeg<0] {
                set harmonicPhaseDeg [expr $harmonicPhaseDeg+360]
            }
            #set check [expr $voltage*(sin($synchPhase) + $voltageRatio*sin($harmonicPhase))-$U1]
            #puts stderr "check: $check"
            set synchTune0 [expr sqrt($alphac*$harmonic*cos($synchPhase)*$voltage/(2*$pi*$energy))]
            set synchFreq ?
            set synchTune ?
            set rfAcceptance ?
            set coupling ?
            set bunchLength [expr 2/3.6256*pow(3./($m*$m-1), 0.25)*sqrt(2*$harmonic*$alphac*$Sdelta0/$synchTune0)*$cMKS/$omegaRF]
        }
        Custom {
            if [expr $voltageRatio<0] {
                set voltageRatio 0
            }
            set harmonicPhase [expr $harmonicPhaseDeg*$pi/180.]
            set U2 [expr $U1-$voltageRatio*$voltage*sin($harmonicPhase)]
            set synchPhase [expr asin($U2/$voltage)]
            set synchPhaseDeg [expr $synchPhase*180/$pi]
            set synchTune0 [expr sqrt($alphac*$harmonic*cos($synchPhase)*$voltage/(2*$pi*$energy))]
            set synchTune ?
            set synchFreq ?
            set bunchLength [expr $Sdelta0*$cMKS*sqrt($alphac*$energy/($revFreq1*$omegaRF*cos($synchPhase)*$voltage))/sqrt(1 + $harmonicRatio*$voltageRatio/cos($synchPhase))]
            set coupling ?
        }
    }

    set synchPhaseDeg [expr 180-180.0*$synchPhase/$pi]
    set lastHarmonicMode $harmonicMode

    computeBunchShape -plot $plot
    findFixedPoints
    computeBucketHH
    
    update
}

proc findFixedPoints {} {
    global dataItemList
    eval global $dataItemList bunchLength harmonic voltage synchPhaseDeg twiss
    global overVoltage rfAcceptance rfFrequency synchFreq coupling extradE synchTune energy
    global bunchDuration superPeriods revFreq1 sMax1 sMax
    global harmonicRatio voltageRatio harmonicMode lastHarmonicMode harmonicPhaseDeg
    global pi cMKS U1 sMax1 revFreq1 energy omegaRF rfFrequency

    #puts stderr "findFixedPoints: $voltage, $voltageRatio $harmonicRatio $synchPhaseDeg $harmonicPhaseDeg $U1"
    set dataList [exec sddssequence -pipe=out -define=dphi -sequence=begin=[expr -2*$pi],end=[expr 2*$pi],n=1000000 \
		      | sddsprocess -pipe -clip=1,0 \
		      "-define=param,V1,$voltage" "-define=param,Vh,$voltage $voltageRatio *" \
		      "-define=param,h,$harmonicRatio" \
		      "-define=param,phi1,$synchPhaseDeg pi * 180 /" "-define=param,phih,$harmonicPhaseDeg pi * 180 /" \
		      "-define=param,U0,$U1" \
		      "-define=column,error,U0 V1 phi1 dphi + sin * - Vh phih dphi h * + sin * -" \
		      "-define=column,deriv,V1 phi1 dphi + cos * Vh phih dphi h * + sin * h * + chs" \
		      | sddszerofind -pipe -zeroesOf=error -columns=dphi,deriv \
		      | sddsprocess -pipe "-test=column,deriv 0 <" \
		      | sdds2stream -pipe -column=dphi]
    global fixedPoint
    if [llength $dataList]>1 {
	set fixedPoint(1) [lindex $dataList 0]
	set fixedPoint(2) [lindex $dataList 1]
	set fixedPoint(valid) 1
    } else {
	set fixedPoint(valid) 0
    }
}

proc computeBucketHH {args} {
    global dataItemList
    eval global $dataItemList bunchLength harmonic voltage synchPhaseDeg twiss
    global overVoltage rfAcceptance rfFrequency synchFreq coupling extradE synchTune energy
    global bunchDuration superPeriods revFreq1 sMax1 sMax
    global harmonicRatio voltageRatio harmonicMode lastHarmonicMode harmonicPhaseDeg
    global pi cMKS U1 sMax1 revFreq1 energy omegaRF rfFrequency
    global fixedPoint rfAcceptance

    if $fixedPoint(valid)==0 return
    set fp $fixedPoint(1)
    set phi1 [expr $synchPhaseDeg*$pi/180]
    set phih [expr $harmonicPhaseDeg*$pi/180]
    set Vh [expr $voltageRatio*$voltage]
    set W1 [expr $voltage*(cos($phi1) - cos($phi1+$fp))]
    set W2 [expr $Vh*(cos($phih) - cos($phih+$fp*$harmonicRatio))/$harmonicRatio]
    set W3 [expr $U1*$fp]
    set W [expr $W1+$W2-$W3]
    if [expr $W>=0] {
        set rfAcceptance 0
    } else {
	set rfAcceptance [expr sqrt(-$W/($pi*$harmonic*$alphac*$energy))*100]
    }
    
}

proc computeBunchShape {args} {
    set plot 0
    APSStrictParseArguments {plot}
    global dataItemList
    eval global $dataItemList bunchLength harmonic voltage synchPhaseDeg twiss
    global overVoltage rfAcceptance rfFrequency synchFreq coupling extradE synchTune energy
    global bunchDuration superPeriods revFreq1 sMax1 sMax
    global harmonicRatio voltageRatio harmonicMode lastHarmonicMode harmonicPhaseDeg
    global pi cMKS U1 sMax1 revFreq1 energy omegaRF rfFrequency fractionalSpan

    set outFile  $twiss.longit
    if [catch {exec touch $outFile} result] {
        set outFile /tmp/[file tail $twiss].longit
    }
    exec sddssequence -pipe=out -define=t,type=double,units=s -sequence=begin=[expr -$fractionalSpan*1e-6/$rfFrequency],end=[expr $fractionalSpan*1e-6/$rfFrequency],n=10000 \
        | sddsprocess -pipe=in $outFile \
        "-define=param,C1,[expr $alphac*$cMKS*$voltage/($energy*$sMax1*$omegaRF)]" \
        "-define=param,alphac,$alphac" \
        "-define=param,Sdelta0,$Sdelta0" \
        "-define=param,phis,$synchPhaseDeg dtor" \
        "-define=param,k,$voltageRatio" \
        "-define=param,n,$harmonicRatio,type=short" \
        "-define=param,phih,$harmonicPhaseDeg dtor" \
        "-define=param,omega,$omegaRF" \
        "-define=col,phi,omega t *" \
        "-define=col,Phi1,phis cos  phi     phis + cos -" \
        "-define=col,Phi2,phih cos  phi n * phih + cos - k * n /" \
        "-define=col,Phi3,phis sin  phih sin k * + phi *" \
        "-define=col,Phi,Phi1 Phi2 + Phi3 - C1 *" \
        "-define=col,rhoArg,Phi alphac sqr / Sdelta0 sqr / chs" \
        -process=rhoArg,min,%sMin \
        "-define=col,rho,rhoArg chs exp" \
        -process=rho,integ,rhoInteg,functionOf=t \
        "-redefine=col,rho,rho rhoInteg /" \
        -process=t,rms,tRms,weight=rho

    set bunchDuration [exec sdds2stream -parameter=tRms $outFile]
    set bunchLength [expr $bunchDuration*$cMKS]

    if $plot {
        exec sddsplot -column=t,rho $outFile -title=@tRms &
    }
}

proc outputForElegantDialog {} {
    global code outputFile rfMainName rfHarmonicName harmonicMode
    global voltage rfFrequency synchPhaseDeg voltageRatio harmonicRatio harmonicPhaseDeg
    APSDialogBox .output -modal 0 -okCommand "set code 1" -cancelCommand "set code 0" \
        -name "Elegant output"
    APSLabeledEntry .le1 -parent .output.userFrame -label "Filename: " \
        -textVariable outputFile -width 80 
    APSLabeledEntry .le2 -parent .output.userFrame -label "Main rf element name: " \
        -textVariable rfMainName -width 80
    if {[string compare $harmonicMode None] && $harmonicRatio>1} {
        APSLabeledEntry .le3 -parent .output.userFrame -label "Harmonic rf element name: " \
          -textVariable rfHarmonicName -width 80 
        set doHarmonic 1
    } else {
        set doHarmonic 0
        set rfHarmonicName ""
    }
    update
    tkwait variable code
    if {$code && [string length $outputFile] && [string length $rfMainName] && (!$doHarmonic || [string length $rfHarmonicName])} {
        compute -plot 0
        lappend ElementNameList $rfMainName $rfMainName $rfMainName 
        lappend ElementParameterList VOLT FREQ PHASE
        lappend ParameterValueList [expr $voltage*1e6] [expr $rfFrequency*1e6] $synchPhaseDeg
        if $doHarmonic {
            lappend ElementNameList $rfHarmonicName $rfHarmonicName $rfHarmonicName
            lappend ElementParameterList VOLT FREQ PHASE
            lappend ParameterValueList [expr $voltage*1e6*$voltageRatio] [expr $rfFrequency*1e6*$harmonicRatio] $harmonicPhaseDeg
        }
        exec sddsmakedataset $outputFile \
          -column=ElementName,type=string -data=[join $ElementNameList ,] \
          -column=ElementParameter,type=string -data=[join $ElementParameterList ,] \
          -column=ParameterValue,type=double -data=[join $ParameterValueList ,]
    }
}

compute
APSButton .compute -parent .userFrame -text Compute -command "compute -plot 0"
APSButton .plot -parent .userFrame -text Plot -command "compute -plot 1"
APSButton .output  -parent .userFrame -text ">Elegant" -command outputForElegantDialog
