#!/bin/sh  
# \
exec oagtclsh "$0" "$@"

if [info exists $env(OAG_TOP_DIR)] {
    set auto_path [linsert $auto_path 0  $env(OAG_TOP_DIR)/oag/apps/lib/$env(HOST_ARCH)]
} else {
    set auto_path [linsert $auto_path 0  /usr/local/oag/apps/lib/$env(HOST_ARCH)]
}

APSStandardSetup

set usage {usage: elasticScatteringAnalysis -tracking <inputFile> -twiss <inputFile> -pressure <inputFile> -output <filename> [-nbins <number>(100)] [-verbose 1]}
set tracking ""
set twiss ""
set pressure ""
set output ""
set verbose 0
set nbins 100
set args $argv
if {[APSStrictParseArguments {tracking twiss pressure output nbins verbose}] || [expr $nbins<2]} {
    return -code error "$usage"
}

foreach arg {tracking twiss pressure output} isOutput {0 0 0 1} {
    if ![string length [set $arg]] {
        puts stderr "$usage"
        exit 1
    }
    if $isOutput {
        if [file exists [set $arg]] {
            puts stderr "in use: [set $arg]"
            exit 1
        }
    } else {
        if ![file exists [set $arg]] {
            puts stderr "not found: [set $arg]"
            exit 1
        }
    }
}


set tmpRoot /tmp/[APSTmpString]

# Set up arrays for known gasses
# C(gas) = num. of Constituent atom types
# Z(gas,n) = Z of nth constituent
# S(gas,n) = num. of atoms of type n

set C(H2) 1
set Z(H2,1) 1
set S(H2,1) 2

set C(H2O) 2
set Z(H2O,1) 1
set S(H2O,1) 2
set Z(H2O,2) 8
set S(H2O,2) 1

set C(CH4) 2
set Z(CH4,1) 6
set S(CH4,1) 1
set Z(CH4,2) 1
set S(CH4,2) 4

set C(CO) 2
set Z(CO,1) 6
set S(CO,1) 1
set Z(CO,2) 8
set S(CO,2) 1

set C(CO2) 2
set Z(CO2,1) 6
set S(CO2,1) 1
set Z(CO2,2) 8
set S(CO2,2) 2

set C(N2) 1
set Z(N2,1) 7
set S(N2,1) 2

set knownSpeciesList [array names C]

set columnList [exec sddsquery -column $pressure]
set speciesList ""
foreach column $columnList {
    if [lsearch -exact $knownSpeciesList $column]!=-1 {
        lappend speciesList $column
    } else {
        if [string compare $column s]!=0 {
            puts stderr "Warning: unexpected column \"$column\" in $pressureData"
        }
    }
}

if [llength $speciesList]==0 {
    return -code error "no known gas species ([join $knownSpeciesList ,]) identified in list of columns: [join $columnList ,]"
}

# Check units of pressure values
array set units [exec sddsquery -column $pressure -appendunits=bare]
foreach species $speciesList {
    if [lsearch -exact [list nT nTorr] $units($species)]==-1 {
        return -code error "units for $species are not valid: $units($species); use nT or nTorr"
    }
}

# Compute Fg factor for each species
# Fg = sum(a=1,Cg) E(g,a)*S(g,a), where E(g,a) = (Z(g,a)*re/(2*gamma))^2
# Then, find the sum G over all species of Fg*ng(s), where ng(s) is the
# number density
set gamma [lindex [exec sdds2stream -parameter=pCentral $twiss] 0]
set re 2.81794092e-15
set PConv [expr 133.3224*1e-9]
set rateSumOpt "-define=column,rate,0 "
set T [expr 20+273.15]
set GList ""
set GSum "0 "
foreach g $speciesList {
    set Fg 0.0
    for {set a 1} {$a<=$C($g)} {incr a} {
        set Fg [expr $Fg+$Z($g,$a)*$Z($g,$a)*$S($g,$a)]
    }
    set Fg [expr $Fg*pow($re/(2*$gamma), 2)]
    lappend GList "-define=column,g$g,$g $PConv * kb_mks / $T / $Fg *,units=1/m" 
    set GSum "$GSum g$g +"
}
#APSAddToTempFileList $tmpRoot.pres
eval exec sddsprocess $pressure $tmpRoot.pres $GList "{-define=col,G,$GSum,units=1/m}"

# Ensure that twiss file is nicely ordered with no duplicate points
#APSAddToTempFileList $tmpRoot.twi $tmpRoot.twi1
exec sddssort $twiss $tmpRoot.twi -col=s -unique
exec removeBackDrifts -input $tmpRoot.twi -output $tmpRoot.twi1

# Find unique scattering locations
exec sddssort $tracking $tmpRoot.sloc -column=s -unique

# Find endpoints surrounding each scattering point
exec sddsprocess $tmpRoot.sloc $tmpRoot.endp \
    "-define=col,sStart,i_row 0        == ? s : i_row 1 - &s \[ s + 2 / $,units=m" \
    "-define=col,sEnd,i_row n_rows 1 - == ? s : i_row 1 + &s \[ s + 2 / $,units=m" 
set sLocList [exec sdds2stream $tmpRoot.endp -column=s]    
set sStartList [exec sdds2stream $tmpRoot.endp -column=sStart]
set sEndList [exec sdds2stream $tmpRoot.endp -column=sEnd]
set betax0List [exec sddsinterp $tmpRoot.twi1 -col=s,betax -filevalues=$tmpRoot.sloc,column=s -pipe=out | sdds2stream -pipe -col=betax]
set betay0List [exec sddsinterp $tmpRoot.twi1 -col=s,betay -filevalues=$tmpRoot.sloc,column=s -pipe=out | sdds2stream -pipe -col=betay]

set LTotal [exec sddsprocess $twiss -pipe=out -process=s,max,%sMax | sdds2stream -pipe -parameter=sMax]
set LSim [expr [lindex $sEndList end]-[lindex $sStartList 0]]
set LFactor [expr $LTotal/$LSim]
if $verbose {
    puts stderr "LSim=$LSim, LTotal=$LTotal"
}

set index 0
foreach sLoc $sLocList sStart $sStartList sEnd $sEndList betax0 $betax0List betay0 $betay0List {
    if $verbose {
        puts stderr "** sScat=$sLoc, s:\[$sStart, $sEnd]\n  betax0=$betax0, betay0=$betay0"
    }
    set s0 [expr $sLoc-1e-9]
    set s1 [expr $sLoc+1e-9]
    # Figure out dphi and dtheta 
    set dphi [exec sddsprocess $tracking -pipe=out -filter=col,s,$s0,$s1 \
        | sddssort -pipe -column=phi -unique \
        | sddsprocess -pipe \
        "-define=col,dphi,i_row 0 == ? 1e300 : phi i_row 1 - &phi \[ - $ " \
        -process=dphi,min,%sMin \
        | sdds2stream -pipe -parameter=dphiMin]
    set dtheta [exec sddsprocess $tracking -pipe=out -filter=col,s,$s0,$s1 \
        | sddssort -pipe -column=theta -unique \
        | sddsprocess -pipe \
        "-define=col,dtheta,i_row 0 == ? 1e300 : theta i_row 1 - &theta \[ - $ " \
        -process=dtheta,min,%sMin \
        | sdds2stream -pipe -parameter=dthetaMin]
    if $verbose {
        puts stderr "dphi=$dphi, dtheta=$dtheta"
    }

    # Interpolate to 1mm spacing so that integrals are not likely to be zero when
    # only a single data point is in the interval
    set W [exec sddsinterp $tmpRoot.twi1 -pipe=out -column=s,betax,betay -equispaced=0.001 \
             | sddsprocess -pipe -filter=column,s,$sStart,$sEnd \
             "-define=column,weight,betax $betax0 / betay $betay0 / * sqrt" \
             -process=weight,gminteg,weightInteg,functionOf=s \
             | sdds2stream -pipe -parameter=weightInteg]
    set GAve [exec sddsinterp $tmpRoot.pres -pipe=out -column=s,G -equispaced=0.001,$sStart,$sEnd -above=wrap \
                  | sddsprocess -pipe \
                  -process=G,gminteg,Ginteg,functionOf=s \
                  -process=s,spread,%sSpread \
                  "-define=parameter,GAve,Ginteg sSpread /" \
                  | sdds2stream -pipe -parameter=GAve]
    if $verbose {
        puts stderr "s:\[$sStart, $sEnd] : W=$W, <G>=$GAve"
    }
    exec sddsprocess $tracking $tracking.proc[format %06d $index] \
      -filter=col,s,$s0,$s1 \
      -define=parameter,betax0,$betax0,units=m \
      -define=parameter,betay0,$betay0,units=m \
      -define=parameter,dphi,$dphi -define=parameter,dtheta,$dtheta \
      -define=parameter,GAve,$GAve,units=1/m \
      -define=parameter,W,$W,units=m \
      -process=s,first,s \
      "-define=column,rate,theta sin theta 2 / sin 4 pow / dphi * dtheta * GAve * W * c_mks * $LFactor * $LTotal /,units=1/s" \
      "-process=rate,sum,rateSum" 

    lappend trackingList $tracking.proc[format %06d $index] 
    incr index
}

if $verbose {
    puts stderr "generating $output"
}
eval exec sddscombine $trackingList -pipe=out \
    | tee $output.full \
    | sddscombine -pipe -merge \
    | sddshist -pipe=in $output.his -data=sLost -weight=rate -bins=$nbins -norm=sum

eval exec sddscombine $trackingList -collapse -pipe=out \
  | sddsprocess -pipe=in $output -process=rateSum,sum,rateTotal \
  "{-define=parameter,lifetime,rateTotal rec 3600 /,units=h}" 

eval file delete $trackingList
