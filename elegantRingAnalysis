#!/bin/sh
# \
exec oagwish "$0" "$@"

#
# $Log: elegantRingAnalysis,v
#

set auto_path [linsert $auto_path 0  /usr/local/oag/apps/lib/$env(HOST_ARCH)]
set auto_path [linsert $auto_path 0  /usr/local/oag/lib_patch/$env(HOST_ARCH)]
APSDebugPath
set CVSRevisionAuthor "\$Author: borland $"

APSApplication . -name elegantRingAnalysis \
  -overview "Performs various elegant simulations for a ring."
.menu.file.menu insert 1 command -label "Save as..." -command SaveConfiguration
.menu.file.menu insert 1 command -label "Read..." -command ReadConfiguration

set status "Working..."
APSScrolledStatus .status -parent .userFrame -textVariable status -height 10 -width 95 

set sourceDir $env(HOME)/elegantRingAnalysisTemplates

proc setStatus {text} {
    APSSetVarAndUpdate status $text
    update
}

proc affix {args} {
    set prefix ""
    set itemList ""
    set suffix ""
    if [APSStrictParseArguments {prefix itemList suffix}] {
        return -code error "affix: Invalid arguments"
    }
    set returnList ""
    foreach item $itemList {
        lappend returnList ${prefix}${item}${suffix}
    }
    return $returnList
}

set momentum 7.0e3
set matrixLatticeFile ""
set matrixBeamline RING
set matrixOffsetElement MALIN
set kickLatticeFile ""
set kickBeamline RING
set kickOffsetElement MALIN
set mainParameterFile(1) ""
set mainParameterFile(2) ""
set mainParameterFile(3) ""
set mainParameterFile(4) ""
set mainDirectory [pwd]
set mainPrefix ""
set gridEngine 0

proc SaveConfiguration {} {
    global mainDirectory saveVarList
    set configFile [APSFileSelectDialog .saveDialog -listDir $mainDirectory \
                     -checkValidity 0]
    if ![string length $configFile] return
    if [file exists $configFile] {
        if {[APSMultipleChoice [APSUniqueName .] \
               -question "$configFile exists already.  What do you want to do?" \
               -returnList {0 1} \
               -labelList {Overwrite Cancel}]} {
            return
        }
    }
    set fd [open $configFile w]
    eval global $saveVarList
    foreach variable $saveVarList {
        set names [array names $variable]
        if ![llength $names] {
            puts $fd "set $variable [set $variable]"
        } else {
            foreach name $names {
                puts $fd "set $variable\($name\) [set $variable\($name\)]" 
            }
        }
    }
    close $fd
    setStatus "Configuration $configFile written."
}

proc ReadConfiguration {} {
    global mainDirectory saveVarList
    eval global $saveVarList
    set configFile [APSFileSelectDialog .saveDialog -listDir $mainDirectory \
                     -checkValidity 1]
    if ![string length $configFile] return
    if ![file exists $configFile] return
    source $configFile
    setStatus "Configuration $configFile read."
}

proc FillMainFrame {widget args} {
    APSLabeledEntry .le1 -parent $widget -label "Momentum (MeV/c): " \
      -width 60 -textVariable momentum -contextHelp \
      "Enter the beam momentum in MeV/c."
    APSLabeledEntry .le2 -parent $widget -label "Matrix lattice file: " \
      -width 60 -textVariable matrixLatticeFile -fileSelectButton 1 -fileSelectPattern *.lte \
      -contextHelp \
      "Enter the name of the lattice file that uses matrix-based elements."
    APSLabeledEntry .le2a -parent $widget -label "Matrix beamline: " \
      -width 60 -textVariable matrixBeamline \
      -contextHelp \
      "Enter the name of the beamline for the matrix representation"
    APSLabeledEntry .le2b -parent $widget -label "Offset element for matrix beamline: " \
      -width 60 -textVariable matrixOffsetElement \
      -contextHelp \
      "Enter the name of the offset element (MALIGN) for the beamline for the matrix representation.  It should be at the start of the beamline."

    APSLabeledEntry .le3 -parent $widget -label "Tracking lattice file: " \
      -width 60 -textVariable kickLatticeFile -fileSelectButton 1 -fileSelectPattern *.lte \
      -contextHelp \
      "Enter the name of the lattice file that uses kick-based elements for tracking."
    APSLabeledEntry .le3a -parent $widget -label "Kick beamline: " \
      -width 60 -textVariable kickBeamline \
      -contextHelp \
      "Enter the name of the beamline for the kick representation"
    APSLabeledEntry .le3b -parent $widget -label "Offset element for kick beamline: " \
      -width 60 -textVariable kickOffsetElement \
      -contextHelp \
      "Enter the name of the offset element (MALIGN) for the beamline for the kick representation.  It should be at the start of the beamline."

    foreach item {1 2 3 4} {
        APSLabeledEntry .le4$item -parent $widget -label "Parameter file (optional): " \
          -width 60 -textVariable mainParameterFile($item) -fileSelectButton 1 -fileSelectPattern *.param \
          -contextHelp \
          "Enter the name of the parameter file that contains element parameters.  It will be loaded over the lattice."
    }
    APSLabeledEntry .le5 -parent $widget -label "Output directory: " \
      -width 60 -textVariable mainDirectory \
      -fileSelectButton 1 -fileSelectDirectory 1 \
      -contextHelp \
      "Enter the directory in which to place calculation results." 
    APSLabeledEntry .le6 -parent $widget -label "Output file prefix (optional): " \
      -width 60 -textVariable mainPrefix \
      -contextHelp "Enter an optional prefix to use in creating output filenames."

    APSRadioButtonFrame .rb1 -parent $widget -label "Use GridEngine? " -orientation horizontal \
      -variable gridEngine -buttonList "Yes No" -valueList "1 0" \
      -contextHelp "Select whether or not to use the GridEngine queue to run jobs in parallel."
}

proc FillBasicFrame {widget args} {
    global basicComputations
    foreach item [list Chromaticity HigherOrderChromaticity ChromaticTuneSpread \
                    RadiationIntegrals ] {
        set basicComputations(do$item) 0
        lappend variableList basicComputations(do$item) 
    }
    APSCheckButtonFrame .cb1 -parent $widget \
      -label "Include: " -allNone 1 -limitPerRow 4 \
      -buttonList [list Chromaticity "Higher-order chromaticity" "Chromatic Tune Spread" \
                     "Radiation Integrals" ] \
      -variableList $variableList 

    set basicComputations(chromaticTuneSpreadMomentumSpread) 0.015
    APSLabeledEntry .le1 -parent $widget -width 20 \
      -label "Momentum fractional half-range for chromatic tune spread: " \
      -textVariable basicComputations(chromaticTuneSpreadMomentumSpread) 

    set basicComputations(driftDivisions) 1
    set basicComputations(dipoleDivisions) 1
    set basicComputations(quadDivisions) 1
    set basicComputations(sextDivisions) 1
    set basicComputations(edgeOrder) 1
    set basicComputations(finalSTwiss) 0.0
    APSLabeledEntry .le2 -parent $widget -width 20 \
      -label "Drift divisions: " -type integer \
      -textVariable basicComputations(driftDivisions)
    APSLabeledEntry .le3 -parent $widget -width 20 \
      -label "Dipole divisions: " -type integer \
      -textVariable basicComputations(dipoleDivisions)
    APSLabeledEntry .le4 -parent $widget -width 20 \
      -label "Quad divisions: " -type integer \
      -textVariable basicComputations(quadDivisions)
    APSLabeledEntry .le41 -parent $widget -width 20 \
      -label "Edge order for dipoles: " -type integer \
      -textVariable basicComputations(edgeOrder) 
    APSLabeledEntry .le5 -parent $widget -width 20 \
        -label "Final s for twiss plots (m): " \
	-textVariable basicComputations(finalSTwiss)

    APSButton .bu1 -parent $widget -text "Compute" -command \
      "BasicComputations -mode run"
    APSButton .bu2 -parent $widget -text "Display" -command \
      "BasicComputations -mode display"
}

proc BasicComputations {args} {
    set mode run
    APSStrictParseArguments {mode}

    global sourceDir 
    global basicComputations momentum matrixLatticeFile mainParameterFile mainDirectory mainPrefix matrixBeamline
    foreach name [array names basicComputations] {
        set $name $basicComputations($name)
    }
    set order 1
    if $doChromaticity {
        set order 2
    }
    if {$doHigherOrderChromaticity || $doChromaticTuneSpread} {
        set order 3
    }
    if {$doChromaticTuneSpread && [expr $chromaticTuneSpreadMomentumSpread<=0]} {
        return -code error "momentum spread must be positive for chromatic tune spread computations"        
    }
    set parameterFileList ""
    foreach item [lsort [array names mainParameterFile]] {
        if [string length $mainParameterFile($item)] {
            append parameterFileList "$mainParameterFile($item) "
        }
    }
    foreach item [array names basicComputations] {
	lappend origList <$item>
	lappend replList [set $item]
    }
    set tag Basic
    if [string compare $mode run]==0 {
        if {![PerformRun -template $sourceDir/BasicTemplate.ele -parameterFileList $parameterFileList \
		  -tag $tag -order $order -momentum $momentum \
		  -originalList $origList -replacementList $replList]} {
            return 
        }
    } else {
        set runDone [file exists $mainDirectory/${mainPrefix}${tag}.done]
        if !$runDone {
            return -code error "$mainDirectory/${mainPrefix}${tag} not done"
        }
    }

    set tmpRoot /tmp/[APSTmpString]
    APSAddToTempFileList $tmpRoot.p1
    if [expr $finalSTwiss>0] {
        exec plotTwiss -fileRoot $mainDirectory/${mainPrefix}${tag} -filter=column,s,0,$finalSTwiss &
    } else {
        exec plotTwiss -fileRoot $mainDirectory/${mainPrefix}${tag} &
    }
    set parameterList -parameter=nu?,end 
    if $doChromaticity {
        lappend parameterList -parameter=dnu?/dp,end 
    }
    if $doHigherOrderChromaticity {
        lappend parameterList -parameter=dnu?/dp2,end -parameter=dnu?/dp3,end 
    }
    if $doChromaticTuneSpread {
        lappend parameterList -parameter=dnu?Chrom,end
    }
    if $basicComputations(doRadiationIntegrals) {
        lappend parameterList -parameter=ex0 -parameter=Sdelta0 -parameter=U0,end
        lappend parameterList -parameter=J? -parameter=Jdelta,end
        lappend parameterList -parameter=tau? -parameter=taudelta,end
    }
    eval exec sddsprocess $mainDirectory/${mainPrefix}${tag}.twi -pipe=out \
      {"-define=parameter,dnuxChrom,nuxChromUpper nuxChromLower -"} \
      {"-define=parameter,dnuyChrom,nuyChromUpper nuyChromLower -"} \
      | sddsprintout -pipe=in $tmpRoot.p1 -title=$mainDirectory/${mainPrefix}${tag}.twi \
      $parameterList -parameter=beta?Max,end -parameter=beta?Min,end \
      -parameter=etaxM*,end 
    APSFileDisplayWindow [APSUniqueName .] -fileName $tmpRoot.p1 -deleteOnClose 1 \
      -height [llength $parameterList] -width 120
}

proc PerformRun {args} {
    set template ""
    set parameterFileList ""
    set order 1
    set momentum 7e3
    set replacementList ""
    set originalList ""
    set tag ""
    set suffix ""
    APSStrictParseArguments {template parameterFileList order momentum \
				 replacementList originalList tag suffix}
    global mainDirectory mainPrefix matrixLatticeFile kickLatticeFile sourceDir 
    global matrixBeamline kickBeamline matrixOffsetElement kickOffsetElement gridEngine
    foreach item [list order momentum mainDirectory mainPrefix matrixLatticeFile kickLatticeFile parameterFileList matrixBeamline kickBeamline matrixOffsetElement kickOffsetElement] {
	lappend originalList <$item>
	lappend replacementList [set $item]
    }
    set command elegant
    if $gridEngine {
	set command "ssub elegant"
    }
    setStatus "Running elegant..."
    set runDone 0
    file delete -force $mainDirectory/${mainPrefix}${tag}${suffix}.done
    exec replaceText $template $mainDirectory/${mainPrefix}${tag}${suffix}.ele \
	-original=[join $originalList ,] -replacement=[join $replacementList ,]
    APSExecLog [APSUniqueName .] -width 100 \
	-unixCommand "$command $mainDirectory/${mainPrefix}${tag}${suffix}.ele" \
	-callback "set runDone 1" \
	-cancelCallback "set runDone 2" -abortCallback "set runDone 2"
    tkwait variable runDone
    if $gridEngine {
	while {![file exists $mainDirectory/${mainPrefix}${tag}${suffix}.done]} {
	    APSWaitWithUpdate -waitSeconds 10 -updateInterval 1
	    setStatus "$mainDirectory/${mainPrefix}${tag}${suffix} not done.  Waiting."
	}
    }
    set runDone [file exists $mainDirectory/${mainPrefix}${tag}${suffix}.done]
    if !$runDone {
        setStatus "Run failed: $mainDirectory/${mainPrefix}${tag}${suffix}.done not found."
        return 0
    }
    setStatus "Run finished."
    return 1
}

proc PerformRuns {args} {
    set template ""
    set parameterFileList ""
    set order 1
    set momentum 7e3
    set replacementList ""
    set originalList ""
    set tag ""
    set variable ""
    set startValue 0
    set endValue 0
    set points 0
    set copyList ""
    set combineList ""
    set mergeList ""
    set suffix ""
    APSStrictParseArguments {template parameterFileList order momentum tag  \
				 variable startValue endValue  points copyList \
				 combineList mergeList suffix \
				 replacementList originalList}
    global mainDirectory mainPrefix matrixLatticeFile kickLatticeFile sourceDir 
    global matrixBeamline kickBeamline matrixOffsetElement kickOffsetElement gridEngine
    foreach item [list order momentum mainDirectory mainPrefix matrixLatticeFile kickLatticeFile parameterFileList matrixBeamline kickBeamline matrixOffsetElement kickOffsetElement] {
	lappend originalList <$item>
	lappend replacementList [set $item]
    }
    set delta [expr ($endValue*1.0-$startValue)/($points-1.0)]
    set w [APSUniqueName .]
    set rootnameList ""
    set command elegant
    if $gridEngine {
        set command "ssub elegant "
    }
    for {set i 0} {$i<$points} {incr i} {
        set value [expr $startValue + $i*$delta]
        setStatus "Running elegant..."
        set runDone 0
        set suffix0 $suffix-[format %03d $i]
        set rootname $mainDirectory/${mainPrefix}${tag}${suffix0}
        exec sddsmakedataset $rootname.var -column=$variable,type=double -data=$value
        eval file delete -force $rootname.done
	exec replaceText $template $rootname.ele \
	    -original=[join $originalList ,],<suffix>,<$variable> \
	    -replacement=[join $replacementList ,],$suffix0,$value
        APSExecLog $w -width 100 \
          -unixCommand "$command $rootname.ele" \
          -callback "set runDone 1" \
          -cancelCallback "set runDone 2" -abortCallback "set runDone 2"
        if !$gridEngine {
            tkwait variable runDone
            set runDone [file exists $rootname.done]
            if !$runDone {
                setStatus "Run failed: $rootname.done not found."
                return 0
            }
            setStatus "Run $i finished."
        } else {
            setStatus "Run $i submitted."
        }
        lappend rootnameList $rootname
    }
    if $gridEngine {
        set doneList [affix -itemList $rootnameList -suffix .done]
        set numDone 0
        set numToDo [llength $doneList]
        while {$numDone!=$numToDo} {
	    APSWaitWithUpdate -waitSeconds 10 -updateInterval 1
            set numDone 0
            foreach done $doneList {
                if [file exists $done] {
                    incr numDone
                }
            }
            setStatus "$numDone of $numToDo jobs done for $mainDirectory/${mainPrefix}${tag}${suffix}"
        }
    }
    setStatus "Postprocessing for $mainDirectory/${mainPrefix}${tag}${suffix}"
    set rootname $mainDirectory/${mainPrefix}${tag}${suffix}
    set processedList ""
    lappend copyList done
    foreach item $copyList {
        if [lsearch -exact $processedList $item]!=-1 continue
        lappend processedList $item
        file copy -force [lindex $rootnameList 0].$item $rootname.$item
	eval file delete -force [affix -itemList $rootnameList -suffix .$item]
    }
    lappend mergeList var
    foreach item $mergeList {
        if [lsearch -exact $processedList $item]!=-1 continue
        lappend processedList $item
        if [catch {eval exec sddscombine [affix -itemList $rootnameList -suffix .$item] \
                     -merge -overwrite $rootname.$item} result] {
        }
        eval file delete -force [affix -itemList $rootnameList -suffix .$item]
    }
    foreach item $combineList {
        if [lsearch -exact $processedList $item]!=-1 continue
        lappend processedList $item
        if [catch {eval exec sddscombine [affix -itemList $rootnameList -suffix .$item] \
                     -overwrite $rootname.$item} result] {
        }
	eval file delete -force [affix -itemList $rootnameList -suffix .$item]
    }
    return 1
}

proc FillPhaseSpaceFrame {widget args} {
    global phaseSpaceTracking
    set phaseSpaceTracking(offsetPlane) X
    set phaseSpaceTracking(otherPlane) Y
    set phaseSpaceTracking(initialOffset) 1e-6
    set phaseSpaceTracking(finalOffset)   1e-3
    set phaseSpaceTracking(otherCoord) 0.0
    set phaseSpaceTracking(sweepPoints) 11
    set phaseSpaceTracking(turns) 1024
    APSRadioButtonFrame .rb1 -parent $widget \
      -label "Plane: " -orientation horizontal -buttonList {x y} -valueList {X Y} \
      -commandList {"set phaseSpaceTracking(otherPlane) Y" "set phaseSpaceTracking(otherPlane) X"} \
      -variable phaseSpaceTracking(offsetPlane) -contextHelp \
      "Choose the plane for which the initial coordinate will be varied."
    APSLabeledEntry .le1 -parent $widget \
      -label "Initial offset for scan (m): " -width 20 -textVariable phaseSpaceTracking(initialOffset) \
      -contextHelp \
      "Enter the initial value of the offset for the swept coordinate."
    APSLabeledEntry .le2 -parent $widget \
      -label "Final offset for scan (m): " -width 20 -textVariable phaseSpaceTracking(finalOffset) \
      -contextHelp \
      "Enter the final value of the offset for the swept coordinate."
    APSLabeledEntry .le2p1 -parent $widget \
      -label "Number of offset values in scan: " -width 20 -textVariable phaseSpaceTracking(sweepPoints) \
      -contextHelp \
      "Enter the number of offset values in the scan."

    APSLabeledEntry .le3 -parent $widget \
      -label "Fixed offset value for the unscanned plane (m): " \
      -width 20 -textVariable phaseSpaceTracking(otherCoord) \
      -contextHelp \
      "Enter the fixed offset value for the unscanned plane."
    APSLabeledEntry .le4 -parent $widget \
      -label "Turns to track: " -width 20 -textVariable phaseSpaceTracking(turns) \
      -contextHelp \
      "Enter the number of turns to track."

    APSButton .bu1 -parent $widget \
      -text "Run" -command "PhaseSpaceTracking -mode run"
    APSButton .bu2 -parent $widget \
      -text "Display" -command "PhaseSpaceTracking -mode display"
}

proc PhaseSpaceTracking {args} {
    set mode display
    APSStrictParseArguments {mode}

    global sourceDir 
    global phaseSpaceTracking momentum matrixLatticeFile mainParameterFile mainDirectory mainPrefix
    global kickOffsetElement
    set parameterFileList ""
    foreach item [lsort [array names mainParameterFile]] {
        if [string length $mainParameterFile($item)] {
            append parameterFileList "$mainParameterFile($item) "
        }
    }
    foreach item [array names phaseSpaceTracking] {
	lappend origList <$item>
	lappend replList [set phaseSpaceTracking($item)]
    }
    set plane [string tolower $phaseSpaceTracking(offsetPlane)]
    set Plane $phaseSpaceTracking(offsetPlane)
    set tag PhaseSpaceTracking
    set rootname $mainDirectory/${mainPrefix}${tag}${Plane}
    set variable offset
    if [string compare $mode run]==0 {
        if {![PerformRuns -template $sourceDir/PhaseSpaceTrackingTemplate.ele -parameterFileList $parameterFileList \
		  -variable $variable \
		  -startValue $phaseSpaceTracking(initialOffset) \
		  -endValue $phaseSpaceTracking(finalOffset) \
		  -points $phaseSpaceTracking(sweepPoints) \
		  -copyList done -combineList w1 -mergeList [list var ele ele.log] \
		  -replacementList $replList -originalList $origList \
		  -tag $tag -suffix $Plane -order 3 -momentum $momentum ]} {
            return 
        }
    } else {
        set runDone [file exists $rootname.done]
        if !$runDone {
            return -code error "$rootname not done"
        }
    }
    set otherPlane [string tolower $phaseSpaceTracking(otherPlane)]
    exec sddsplot -col=C${plane},C${plane}p -graph=dot ${rootname}.w1 \
	"-topline=${rootname}" &
    if [expr $phaseSpaceTracking(otherCoord)!=0.0] {
        exec sddsplot -col=C${otherPlane},C${otherPlane}p -graph=dot ${rootname}.w1 \
	    "-topline=${rootname}" &
    }
    exec sddsexpand ${rootname}.var ${rootname}.vare
    exec sddsfft ${rootname}.w1 \
	-column=Pass,C${plane} -window -suppressAverage -pipe=out \
	| sddsxref -pipe ${rootname}.vare -leave=* -transfer=parameter,* \
	| sddsprocess -pipe=in ${rootname}.w1.fft \
	"-print=parameter,${plane}Label,${plane}0 = %.5f,offset"
    exec sddsplot -column=f,FFTC${plane} ${rootname}.w1.fft \
	-title=@${plane}Label -separate=page -split=page -mode=y=log,y=special \
	-topline=$rootname &
    exec sddsnaff ${rootname}.w1 -pipe=out -columns=Pass,C${plane},C${otherPlane} \
	-terminateSearch=frequencies=1 -nowarnings \
	| sddscombine -pipe -merge \
	| sddsxref -pipe=in ${rootname}.var -take=* ${rootname}.w1.naff
    exec sddsplot -topline=$rootname \
	-column=C${plane}Amplitude,C${plane}Frequency ${rootname}.w1.naff -end \
	-column=C${plane}Amplitude,C${otherPlane}Frequency ${rootname}.w1.naff &
}

proc FillOffMomentumTunesFrame {widget args} {
    global offMomentumTuneTracking
    set offMomentumTuneTracking(initialOffset) -0.01
    set offMomentumTuneTracking(finalOffset) 0.01
    set offMomentumTuneTracking(xOffset) 1e-6
    set offMomentumTuneTracking(yOffset) 1e-6
    set offMomentumTuneTracking(sweepPoints) 11
    set offMomentumTuneTracking(turns) 1024
    set offMomentumTuneTracking(superperiodicity) 1
    APSLabeledEntry .le1 -parent $widget \
      -label "Initial momentum offset for scan: " -width 20 -textVariable offMomentumTuneTracking(initialOffset) \
      -contextHelp \
      "Enter the initial value of the fractional momentum offset."
    APSLabeledEntry .le2 -parent $widget \
      -label "Final momentum offset for scan: " -width 20 -textVariable offMomentumTuneTracking(finalOffset) \
      -contextHelp \
      "Enter the final value of the fractional momentum offset."
    APSLabeledEntry .le2p1 -parent $widget \
      -label "Number of offset values in scan: " -width 20 -textVariable offMomentumTuneTracking(sweepPoints) \
      -contextHelp \
      "Enter the number of offset values in the scan."

    APSLabeledEntry .le3 -parent $widget \
      -label "Fixed offset value for x plane (m): " \
      -width 20 -textVariable offMomentumTuneTracking(xOffset) \
      -contextHelp \
      "Enter the fixed offset value for the x plane."
    APSLabeledEntry .le3p1 -parent $widget \
      -label "Fixed offset value for y plane (m): " \
      -width 20 -textVariable offMomentumTuneTracking(yOffset) \
      -contextHelp \
      "Enter the fixed offset value for the y plane."

    APSLabeledEntry .le4 -parent $widget \
      -label "Turns to track: " -width 20 -textVariable offMomentumTuneTracking(turns) \
      -contextHelp \
      "Enter the number of turns to track."

    APSLabeledEntry .le4p1 -parent $widget \
      -label "Superperiodicity (for resonance diagram): " \
      -width 20 -textVariable offMomentumTuneTracking(superperiodicity) \
      -contextHelp \
      "Enter the superperiodicity of the lattice.  This is used only in generating the resonance diagram."

    APSButton .bu1 -parent $widget \
      -text "Run" -command "OffMomentumTuneTracking -mode run"
    APSButton .bu2 -parent $widget \
      -text "Display" -command "OffMomentumTuneTracking -mode display"
}

proc OffMomentumTuneTracking {args} {
    set mode display
    APSStrictParseArguments {mode}

    global sourceDir 
    global offMomentumTuneTracking momentum matrixLatticeFile mainParameterFile mainDirectory mainPrefix
    set parameterFileList ""
    if ![file exists $mainDirectory/${mainPrefix}Basic.twi] {
	setStatus "Error: please perform Basic run in order to proceed."
	return
    }
    foreach item [lsort [array names mainParameterFile]] {
        if [string length $mainParameterFile($item)] {
            append parameterFileList "$mainParameterFile($item) "
        }
    }
    foreach item [array names offMomentumTuneTracking] {
	lappend origList <$item>
	lappend replList [set offMomentumTuneTracking($item)]
    }
    set tag OffMomentumTuneTracking
    if [string compare $mode run]==0 {
        if {![PerformRuns -template $sourceDir/OffMomentumTuneTrackingTemplate.ele \
		  -parameterFileList $parameterFileList \
		  -originalList $origList -replacementList $replList \
		  -variable delta \
		  -startValue $offMomentumTuneTracking(initialOffset) \
		  -endValue $offMomentumTuneTracking(finalOffset) \
		  -points $offMomentumTuneTracking(sweepPoints) \
		  -tag $tag -order 3 -momentum $momentum \
		  -copyList done -combineList [list w1 ele ele.log] ]} {
            return 
        }
    } else {
        set runDone [file exists $mainDirectory/${mainPrefix}${tag}.done]
        if !$runDone {
            return -code error "$mainDirectory/${mainPrefix}${tag} not done"
        }
    }
    set nux 0
    set nuy 0
    if {[catch {exec sdds2stream -param=nux $mainDirectory/${mainPrefix}Basic.twi} nux] || \
          [catch {exec sdds2stream -param=nuy $mainDirectory/${mainPrefix}Basic.twi} nuy]} {
        return -code error "$mainDirectory/${mainPrefix}Basic $nux $nuy"
    }
    set nuxInteger [expr int($nux)]
    set nuyInteger [expr int($nuy)]
    if [catch {exec sddsresdiag $mainDirectory/${mainPrefix}${tag}.resdiag \
            -superperiodicity=$offMomentumTuneTracking(superperiodicity) \
            -order=3 -integerTunes=$nuxInteger,$nuyInteger} result] {
        return -code error "$mainDirectory/${mainPrefix}${tag}: $result"
    }
    set dnuxSign 1
    set dnuySign 1
    if [expr ($nux-int($nux))>0.5] {
        set dnuxSign -1
        incr nuxInteger
    }
    if [expr ($nux-int($nux))>0.5] {
        set dnuySign -1
        incr nuyInteger
    }
    set rootname $mainDirectory/${mainPrefix}${tag}
    exec sddsexpand ${rootname}.var ${rootname}.vare
    exec sddsnaff ${rootname}.w1 -pipe=out \
      -columns=Pass,Cx,Cy -terminate=frequencies=1 \
      | sddsprocess -pipe \
      "-define=column,nuxTracking,CxFrequency $dnuxSign * $nuxInteger +" \
      "-define=column,nuyTracking,CyFrequency $dnuySign * $nuyInteger +" \
      | sddsexpand -pipe \
      | sddsxref -pipe ${rootname}.vare  \
      -leave=* -transfer=parameter,* \
      | sddscollapse -pipe=in ${rootname}.w1.naff
    
    exec sddsplot -aspect=1 -topline=$rootname \
	-column=nuxTracking,nuyTracking ${rootname}.w1.naff \
	-split=column=delta,width=1e-4 -graph=symbol,vary=subtype -orderColors=spectral \
	-column=nux,nuy ${rootname}.resdiag &
    exec sddsplot -column=delta,nu?Tracking -separate ${rootname}.w1.naff -topline=$rootname \
	-graph=symbol,connect,scale=2 &
}
 
proc FillHigherOrderDispersionFrame {widget args} {
    global higherOrderDispersion
    set higherOrderDispersion(initialOffset) -0.01
    set higherOrderDispersion(finalOffset) 0.01
    set higherOrderDispersion(sweepPoints) 11
    set gridEngine 0
    APSLabeledEntry .le1 -parent $widget \
      -label "Initial momentum offset for scan: " -width 20 -textVariable higherOrderDispersion(initialOffset) \
      -contextHelp \
      "Enter the initial value of the fractional momentum offset."
    APSLabeledEntry .le2 -parent $widget \
      -label "Final momentum offset for scan: " -width 20 -textVariable higherOrderDispersion(finalOffset) \
      -contextHelp \
      "Enter the final value of the fractional momentum offset."
    APSLabeledEntry .le2p1 -parent $widget \
      -label "Number of offset values in scan: " -width 20 -textVariable higherOrderDispersion(sweepPoints) \
      -contextHelp \
      "Enter the number of offset values in the scan."

    APSButton .bu1 -parent $widget \
      -text "Run" -command "HigherOrderDispersion -mode run"
    APSButton .bu2 -parent $widget \
      -text "Display" -command "HigherOrderDispersion -mode display"
}

proc HigherOrderDispersion {args} {
    set mode display
    APSStrictParseArguments {mode}

    global sourceDir 
    global higherOrderDispersion momentum matrixLatticeFile mainParameterFile mainDirectory mainPrefix
    global kickOffsetElement
    set parameterFileList ""
    foreach item [lsort [array names mainParameterFile]] {
        if [string length $mainParameterFile($item)] {
            append parameterFileList "$mainParameterFile($item) "
        }
    }
    foreach item [array names higherOrderDispersion] {
	lappend origList <$item>
	lappend replList [set higherOrderDispersion($item)]
    }
    set tag HigherOrderDispersion
    set rootname $mainDirectory/${mainPrefix}${tag}
    set variable delta
    if [string compare $mode run]==0 {
        catch {file delete $rootname.done}
        if [catch {PerformRuns -template $sourceDir/HigherOrderDispersionTemplate.ele \
		       -parameterFileList $parameterFileList \
		       -variable $variable \
		       -startValue $higherOrderDispersion(initialOffset) \
		       -endValue $higherOrderDispersion(finalOffset) \
		       -points $higherOrderDispersion(sweepPoints) \
		       -copyList [list mag done] -combineList [list clo ele ele.log w1] \
		       -replacementList $replList -originalList $origList \
		       -tag $tag -order 3 -momentum $momentum } runnameList] {
            return -code error "$runnameList"
        }
    } else {
        set runDone [file exists ${rootname}.done]
        if !$runDone {
            return -code error "${rootname} not done"
        }
    }
    if [catch {exec sddsconvert -retain=col,s,x,ElementName,ElementType ${rootname}.clo -pipe=out \
                 | sddsregroup -pipe \
                 | sddsxref -pipe=in $rootname.var $rootname.tmp -take=$variable -reuse=page} result] {
        return -code error "$result"
    }
    set terms [expr int($higherOrderDispersion(sweepPoints)/2)]
    if [catch {exec sddspfit $rootname.tmp -pipe=out -terms=$terms -column=$variable,x \
                | sddsconvert -pipe -delete=column,* \
                | sddsarray2column -pipe -convert=Coefficient \
                | sddstranspose -pipe -root=Coefficient \
                | sddsprocess -pipe -process=Coef*,first,%s \
                | sddscollapse -pipe \
                | sddsxref -pipe=in ${rootname}.clo ${rootname}.disp -take=s,Element*} result] {
        return -code error "$result"
    }
    exec sddsplot -topline=$rootname -column=s,Coefficient* -separate ${rootname}.disp &
}

proc FillDynamicApertureFrame {widget args} {
    global dynamicAperture
    set dynamicAperture(xMinimum) -0.01
    set dynamicAperture(xMaximum)  0.01
    set dynamicAperture(yMaximum)  0.01
    set dynamicAperture(xPoints)   31
    set dynamicAperture(yPoints)   16
    set dynamicAperture(turns) 500

    APSLabeledEntry .le1 -parent $widget \
      -label "Minimum x coordinate (m): " -width 20 -textVariable dynamicAperture(xMinimum) \
      -contextHelp \
      "Enter the minimum x coordinate for the dynamic aperture search"
    APSLabeledEntry .le2 -parent $widget \
      -label "Maximum x coordinate (m): " -width 20 -textVariable dynamicAperture(xMaximum) \
      -contextHelp \
      "Enter the maximum x coordinate for the dynamic aperture search"
    APSLabeledEntry .le3 -parent $widget \
      -label "Number of x points: " -width 20 -textVariable dynamicAperture(xPoints) \
      -contextHelp \
      "Enter the number of points into which to divide the x interval."
    APSLabeledEntry .le4 -parent $widget \
      -label "Maximum y coordinate (m): " -width 20 -textVariable dynamicAperture(yMaximum) \
      -contextHelp \
      "Enter the maximum y coordinate for the dynamic aperture search"
    APSLabeledEntry .le5 -parent $widget \
      -label "Number of y points: " -width 20 -textVariable dynamicAperture(yPoints) \
      -contextHelp \
      "Enter the number of points into which to divide the y interval."
    APSLabeledEntry .le6 -parent $widget \
      -label "Number of turns: " -width 20 -textVariable dynamicAperture(turns) \
      -contextHelp \
      "Enter the number of turns to track."
    
    APSButton .bu1 -parent $widget \
      -text "Run" -command "DynamicAperture -mode run"
    APSButton .bu2 -parent $widget \
      -text "Display" -command "DynamicAperture -mode display"
}

proc DynamicAperture {args} {
    set mode display
    APSStrictParseArguments {mode}

    global sourceDir 
    global dynamicAperture momentum matrixLatticeFile mainParameterFile mainDirectory mainPrefix
    global kickOffsetElement
    set parameterFileList ""
    foreach item [lsort [array names mainParameterFile]] {
        if [string length $mainParameterFile($item)] {
            append parameterFileList "$mainParameterFile($item) "
        }
    }
    foreach item [array names dynamicAperture] {
	lappend origList <$item>
	lappend replList [set dynamicAperture($item)]
    }
    set tag DynamicAperture
    set rootname $mainDirectory/${mainPrefix}${tag}
    if [string compare $mode run]==0 {
        if {![PerformRun -template $sourceDir/DynamicApertureTemplate.ele \
		  -parameterFileList $parameterFileList \
		  -originalList $origList -replacementList $replList \
		  -tag $tag -order 3 -momentum $momentum ]} {
            return 
        }
    } else {
        set runDone [file exists $rootname.done]
        if !$runDone {
            return -code error "$rootname not done"
        }
    }
    exec sddsplot -topline=$rootname \
	-column=x,y $rootname.abnd -column=x,y $rootname.aper -graph=sym,scale=2 &    
}

proc FillOffMomentumDynamicApertureFrame {widget args} {
    global offMomentumDynamicAperture
    set offMomentumDynamicAperture(xMinimum) -0.01
    set offMomentumDynamicAperture(xMaximum)  0.01
    set offMomentumDynamicAperture(yMaximum)  0.01
    set offMomentumDynamicAperture(xPoints)   31
    set offMomentumDynamicAperture(yPoints)   16
    set offMomentumDynamicAperture(deltaMinimum) -0.01
    set offMomentumDynamicAperture(deltaMaximum) 0.01
    set offMomentumDynamicAperture(deltaPoints) 11
    set offMomentumDynamicAperture(turns) 500
    APSLabeledEntry .le1 -parent $widget \
      -label "Minimum x coordinate (m): " -width 20 -textVariable offMomentumDynamicAperture(xMinimum) \
      -contextHelp \
      "Enter the minimum x coordinate for the dynamic aperture search"
    APSLabeledEntry .le2 -parent $widget \
      -label "Maximum x coordinate (m): " -width 20 -textVariable offMomentumDynamicAperture(xMaximum) \
      -contextHelp \
      "Enter the maximum x coordinate for the dynamic aperture search"
    APSLabeledEntry .le3 -parent $widget \
      -label "Number of x points: " -width 20 -textVariable offMomentumDynamicAperture(xPoints) \
      -contextHelp \
      "Enter the number of points into which to divide the x interval."
    APSLabeledEntry .le4 -parent $widget \
      -label "Maximum y coordinate (m): " -width 20 -textVariable offMomentumDynamicAperture(yMaximum) \
      -contextHelp \
      "Enter the maximum y coordinate for the dynamic aperture search"
    APSLabeledEntry .le5 -parent $widget \
      -label "Number of y points: " -width 20 -textVariable offMomentumDynamicAperture(yPoints) \
      -contextHelp \
      "Enter the number of points into which to divide the y interval."
    APSLabeledEntry .le6 -parent $widget \
      -label "Minimum delta value: " -width 20 -textVariable offMomentumDynamicAperture(deltaMinimum) \
      -contextHelp \
      "Enter the minimum delta coordinate for the dynamic aperture search"
    APSLabeledEntry .le7 -parent $widget \
      -label "Maximum delta value: " -width 20 -textVariable offMomentumDynamicAperture(deltaMaximum) \
      -contextHelp \
      "Enter the maximum delta coordinate for the dynamic aperture search"
    APSLabeledEntry .le8 -parent $widget \
      -label "Number of delta points: " -width 20 -textVariable offMomentumDynamicAperture(deltaPoints) \
      -contextHelp \
      "Enter the number of values of delta for which to find dynamic apertures"
    APSLabeledEntry .le9 -parent $widget \
      -label "Number of turns: " -width 20 -textVariable offMomentumDynamicAperture(turns) \
      -contextHelp \
      "Enter the number of turns to track."
    
    APSButton .bu1 -parent $widget \
      -text "Run" -command "OffMomentumDynamicAperture -mode run"
    APSButton .bu2 -parent $widget \
      -text "Display" -command "OffMomentumDynamicAperture -mode display"
}

proc OffMomentumDynamicAperture {args} {
    set mode display
    APSStrictParseArguments {mode}

    global sourceDir 
    global offMomentumDynamicAperture momentum matrixLatticeFile mainParameterFile mainDirectory mainPrefix
    global kickOffsetElement
    set parameterFileList ""
    foreach item [lsort [array names mainParameterFile]] {
        if [string length $mainParameterFile($item)] {
            append parameterFileList "$mainParameterFile($item) "
        }
    }
    foreach item [array names offMomentumDynamicAperture] {
	lappend origList <$item>
	lappend replList [set offMomentumDynamicAperture($item)]
    }
    set tag OffMomentumDynamicAperture
    set rootname $mainDirectory/${mainPrefix}${tag}
    set variable delta
    if [string compare $mode run]==0 {
        if {![PerformRuns -template $sourceDir/OffMomentumDynamicApertureTemplate.ele \
                -parameterFileList $parameterFileList \
                -variable $variable \
                -startValue $offMomentumDynamicAperture(deltaMinimum) \
                -endValue $offMomentumDynamicAperture(deltaMaximum) \
                -points $offMomentumDynamicAperture(deltaPoints) \
                -copyList done -combineList [list aper abnd ele ele.log] \
                -tag $tag -momentum $momentum -originalList $origList -replacementList $replList]} {
            return 
        }
        if [catch {exec sddsexpand $rootname.var $rootname.vare
            exec sddsxref $rootname.aper $rootname.vare -leave=* -transfer=param,delta -nowarning
            file delete -force $rootname.vare $rootname.aper~} result] {
            return -code error "$result"
        }
        
    } else {
        set runDone [file exists $rootname.done]
        if !$runDone {
            return -code error "$rootname not done"
        }
    }
    exec sddsplot -topline=$rootname -same=x,y,global \
      -column=x,y $rootname.aper -graph=sym,scale=2 -split=page -sep=page \
      "-title=@${variable},edit=i/\$gd\$r = /" \
      -column=x,y $rootname.abnd -graph=line -omnipresent &
}

set sectionList [list Main Basic "Phase Space" "Higher-Order Disp." "Off-momentum Tunes" "DA" "Off-Momentum DA"]

set tabFrameWidgetList [APSTabFrame .main -parent .userFrame \
    -labelList $sectionList -width 900 -height 395] 

FillMainFrame  [lindex $tabFrameWidgetList 0]
FillBasicFrame [lindex $tabFrameWidgetList 1]
FillPhaseSpaceFrame [lindex $tabFrameWidgetList 2]
FillHigherOrderDispersionFrame [lindex $tabFrameWidgetList 3]
FillOffMomentumTunesFrame [lindex $tabFrameWidgetList 4]
FillDynamicApertureFrame [lindex $tabFrameWidgetList 5]
FillOffMomentumDynamicApertureFrame [lindex $tabFrameWidgetList 6]

lappend saveVarList momentum matrixLatticeFile kickLatticeFile mainParameterFile mainDirectory mainPrefix gridEngine
lappend saveVarList matrixBeamline kickBeamline matrixOffsetElement kickOffsetElement
lappend saveVarList basicComputations phaseSpaceTracking offMomentumTuneTracking higherOrderDispersion
lappend saveVarList dynamicAperture offMomentumDynamicAperture

set args $argv
set configuration ""
set templateDirectory ""
if {[APSStrictParseArguments {configuration}]} {
    return -code error "usage: $argv0 \[-configuration <filename>\] \[-templateDirectory <path>\]"
}
if {[string length $configuration]} {
    if ![file exists $configuration] {
        setStatus "not found: $configuration"
    } else {
        source $configuration
    }    
}
if [string length $templateDirectory] {
    set sourceDir $templateDirectory
}

setStatus "Ready."
update
